---
hide:
  - toc
---

# Analysis

!!! tip "Quick Links"

    * [Purpose](#the-software-development-lifecycle)
    * [Scope](#the-waterfall-method)
    * [Boundaries](#agile-methods)

!!! info "What you need to know"

    You must be able to describe and compare the development methodologies:

    * iterative development process
    * agile methodologies

## Purpose

The __Purpose__ is a really important part of the analysis stage. It’s all about clearly stating what the software is meant to do – basically, what problem it’s solving or what task it needs to complete. 

A clear purpose helps everyone involved understand what the end goal is, and it makes sure the rest of the project stays on track. 

In addition, it also helps when you’re thinking about what the program will need to take in (__inputs__), what it will do (__processes__), and what it should produce (__outputs__). 

If the purpose isn’t clear, it’s easy for the software to end up doing the wrong thing or not meeting the user’s needs. A good purpose is simple, focused, and makes it easy to check if the final product works the way it’s supposed to.

The SQA define purpose as a __general description__ of the software. 

## Scope

The __Scope__ is where you set the boundaries of what the software will and won’t do. 

Once the purpose is clear, the scope builds on that by outlining exactly what features or tasks will be included in the project – and just as importantly, what’s being left out. 

This helps keep the project realistic and manageable, especially if there are time or resource limits. It also stops feature creep, where new ideas get added in along the way and make everything more complicated. 

A clear scope gives everyone – from developers to users – a shared understanding of what to expect, which makes planning and development much smoother.

## Boundaries

The __Boundaries__ identify what’s outside the system – in other words, the parts the software won’t deal with. While the scope tells us what’s included in the system, boundaries help make it clear where the system ends and where other systems or people take over. 

For example, if a program needs information from a database but doesn’t manage the database itself, that database would be outside the boundary. 

Setting boundaries is useful because it helps avoid confusion about what the software is responsible for. It also makes it easier to plan and design the system by focusing only on what actually needs to be built.


